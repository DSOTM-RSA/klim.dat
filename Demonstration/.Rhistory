library(ReacTran)
# this example uses only the volume fractions
# in the reactive transport term
#====================#
# Model formulation  #
#====================#
# Monod consumption of oxygen (O2)
O2.model <- function (t = 0, O2, pars = NULL) {
tran <- tran.1D(C = O2, C.up = C.ow.O2, D = D.grid,
v = v.grid, VF = por.grid, dx = grid)$dC
reac <- - R.O2*(O2/(Ks+O2))
return(list(dCdt = tran + reac))
}
# First order consumption of organic carbon (OC)
OC.model <- function (t = 0, OC, pars = NULL) {
tran <- tran.1D(C = OC, flux.up = F.OC, D = Db.grid,
v = v.grid, VF = svf.grid, dx = grid)$dC
reac <- - k*OC
return(list(dCdt = tran + reac))
}
O2.model <- function (t = 0, O2, pars = NULL) {
tran <- tran.1D(C = O2, C.up = C.ow.O2, D = D.grid,
v = v.grid, VF = por.grid, dx = grid)$dC
reac <- - R.O2*(O2/(Ks+O2))
return(list(dCdt = tran + reac))
}
# First order consumption of organic carbon (OC)
OC.model <- function (t = 0, OC, pars = NULL) {
tran <- tran.1D(C = OC, flux.up = F.OC, D = Db.grid,
v = v.grid, VF = svf.grid, dx = grid)$dC
reac <- - k*OC
return(list(dCdt = tran + reac))
}
F.OC    <- 25    # input flux organic carbon [micromol cm-2 yr-1]
C.ow.O2 <- 0.25  # concentration O2 in overlying water [micromol cm-3]
por     <- 0.8   # porosity
D       <- 400   # diffusion coefficient O2 [cm2 yr-1]
Db      <- 10    # mixing coefficient sediment [cm2 yr-1]
v       <- 0.1     # advective velocity [cm yr-1]
k       <- 1     # decay constant organic carbon [yr-1]
R.O2    <- 10    # O2 consumption rate [micromol cm-3 yr-1]
Ks      <- 0.005 # O2 consumption saturation constant
# Grid definition
L <- 10   # depth of sediment domain [cm]
N <- 1000  # number of grid layers
grid <- setup.grid.1D(x.up = 0, L = L, N = N)
# Volume fractions
por.grid <- setup.prop.1D(value = por, grid = grid)
svf.grid <- setup.prop.1D(value = (1-por), grid = grid)
D.grid   <- setup.prop.1D(value = D, grid = grid)
Db.grid  <- setup.prop.1D(value = Db, grid = grid)
v.grid   <- setup.prop.1D(value = v, grid = grid)
#====================#
# Model solution     #
#====================#
# Initial conditions + simulation O2
yini <- rep(0, length.out = N)
O2   <- steady.1D(y = yini, func = O2.model, nspec = 1)
yini <- rep(0, length.out = N)
yini <- rep(0, length.out = N)
yini <- rep(0, length.out = N)
OC   <- steady.1D(y = yini, func = OC.model, nspec = 1)
plot(O2, grid = grid$x.mid, xyswap = TRUE, main = "O2 concentration",
ylab = "depth [cm]", xlab = "", mfrow = c(1,2), type = "p", pch = 16)
plot(OC, grid = grid$x.mid, xyswap = TRUE, main = "C concentration",
ylab = "depth [cm]", xlab = "", mfrow = NULL)
temp<- rnorm(365, 5, 10)
mort<- rnorm(365, 300, 45)
poll<- rpois(365,  lambda=76)
date<-seq(as.Date('2011-01-01'),as.Date('2011-12-31'),by = 1)
df<-data.frame(date,mort,poll,temp)
library(lattice)
library(zoo)
z <- read.zoo(df)
# classic graphics in separate and single plots
plot(z)
View(df)
plot(z, screen = 1)
library(lattice)
xyplot(z)
xyplot(z, screen = 1)
View(df)
library(ggplot2)
autoplot(z) + facet_free()
library(ggplot2)
autoplot(z) + facet_free()
library(latticeExtra)
set.seed(1)
dat <- ts(matrix(cumsum(rnorm(200 * 12)), ncol = 12))
colnames(dat) <- paste("series", LETTERS[1:12])
## show simple line plot first, for reference.
xyplot(dat, scales = list(y = "same"))
infolayers <-
layer(panel.scaleArrow(x = 0.99, digits = 1, col = "grey",
srt = 90, cex = 0.7)) +
layer(lim <- current.panel.limits(),
panel.text(lim$x[1], lim$y[1], round(lim$y[1],1), font = 2,
cex = 0.7, adj = c(-0.5,-0.5), col = "#9FC8DC"))
horizonplot(dat, layout = c(1,12), colorkey = TRUE) +
infolayers
horizonplot(dat, layout = c(1,12), horizonscale = 10, colorkey = TRUE) +
infolayers
horizonplot(dat, layout = c(1,12), origin = 0, horizonscale = 10, colorkey = TRUE) +
infolayers
horizonplot(dat, layout = c(1,12), ylim = c(0, 10), colorkey = TRUE) +
infolayers
horizonplot(dat, layout = c(1,12), origin = 0,
scales = list(y = list(relation = "same")),
colorkey = TRUE, colorkey.digits = 1) +
infolayers
horizonplot(dat, horizonscale = 10, colorkey = TRUE,
layout = c(1,12), strip.left = FALSE,
ylab = list(rev(colnames(dat)), rot = 0, cex = 0.7)) +
layer_(panel.fill(col = "gray90"), panel.xblocks(..., col = "white"))
xyplot(EuStockMarkets, scales = list(y = "same"),
panel = function(x, y, ...) {
col <-
c("#B41414","#E03231","#F7A99C","#9FC8DC","#468CC8","#0165B3")
for (i in c(-3:-1, 2:0)) {
if (i >= 0)
yi <- pmax(4000, pmin(y, 4000 + 1000 * (i+1)))
if (i < 0)
yi <- pmin(4000, pmax(y, 4000 + 1000 * i))
panel.xyarea(x, yi, origin = 4000,
col = col[i+4], border = NA)
}
panel.lines(x, y)
panel.abline(h = 4000, lty = 2)
})
horizonplot(EuStockMarkets, colorkey = TRUE,
origin = 4000, horizonscale = 1000) +
infolayers
horizonplot(sunspots, cut = list(n = 23, overlap = 0),
scales = list(draw = FALSE, y = list(relation = "same")),
origin = 100, colorkey = TRUE,
strip.left = FALSE, layout = c(1,23)) +
layer(grid::grid.text(round(x[1]), x = 0, just = "left"))
horizonplot(sunspots, cut = list(n = 23, overlap = 0),
scales = list(draw = FALSE, y = list(relation = "same")),
origin = 100, colorkey = TRUE,
strip.left = FALSE,
layer(grid::grid.text(round(x[1]), x = 0, just = "left"))
horizonplot(sunspots, cut = list(n = 23, overlap = 0),
scales = list(draw = FALSE, y = list(relation = "same")),
origin = 100, colorkey = TRUE,
strip.left = FALSE)
horizonplot(sunspots, cut = list(n = 2, overlap = 0),
scales = list(draw = FALSE, y = list(relation = "same")),
origin = 100, colorkey = TRUE,
strip.left = FALSE)
horizonplot(sunspots, cut = list(n = 1, overlap = 0),
scales = list(draw = FALSE, y = list(relation = "same")),
origin = 100, colorkey = TRUE,
strip.left = FALSE)
horizonplot(sunspots,
scales = list(draw = FALSE, y = list(relation = "same")),
origin = 100, colorkey = TRUE,
strip.left = FALSE)
horizonplot(sunspots,
origin = 100, colorkey = TRUE,
strip.left = FALSE)
horizonplot(sunspots, colorkey = TRUE,
strip.left = FALSE)
horizonplot(sunspots, colorkey = TRUE,origin=100,
strip.left = FALSE)
set.seed(1)
foo <- list(x = 1:100, y = cumsum(rnorm(100)))
## show original data
xyplot(y + y^2 ~ x, foo, type = "l")
## construct separate plots for each series
obj1 <- xyplot(y ~ x, foo, type = "l")
obj2 <- xyplot(y^2 ~ x, foo, type = "l")
## simple case: no axis for the overlaid plot
doubleYScale(obj1, obj2, add.axis = FALSE)
## draw second y axis
doubleYScale(obj1, obj2)
## ...with second ylab
doubleYScale(obj1, obj2, add.ylab2 = TRUE)
## ...or with a key
doubleYScale(obj1, obj2, text = c("obj1", "obj2"))
## ...with custom styles
update(doubleYScale(obj1, obj2, text = c("obj1", "obj2")),
par.settings = simpleTheme(col = c('red','black'), lty = 1:2))
## different plot types
x <- rnorm(60)
doubleYScale(histogram(x), densityplot(x), use.style = FALSE)
## (but see ?as.layer for a better way to do this)
## multi-panel example
## a variant of Figure 5.13 from Sarkar (2008)
## http://lmdvr.r-forge.r-project.org/figures/figures.html?chapter=05;figure=05_13
data(SeatacWeather)
temp <- xyplot(min.temp + max.temp ~ day | month,
data = SeatacWeather, type = "l", layout = c(3, 1))
rain <- xyplot(precip ~ day | month, data = SeatacWeather, type = "h")
doubleYScale(temp, rain, style1 = 0, style2 = 3, add.ylab2 = TRUE,
text = c("min. T", "max. T", "rain"), columns = 3)
## re-plot with different styles
update(trellis.last.object(),
par.settings = simpleTheme(col = c("black", "red", "blue")))
data(EastAuClimate)
## Compare the climates of state capital cities
EastAuClimate[c("Hobart", "Melbourne", "Sydney", "Brisbane"),]
View(EastAuClimate)
lmap <-
function(database = "world", regions = ".", exact = FALSE,
boundary = TRUE, interior = TRUE, projection = "",
parameters = NULL, orientation = NULL,
aspect = "iso", type = "l",
par.settings = list(axis.line = list(col = "transparent")),
xlab = NULL, ylab = NULL, ...)
{
theMap <- map(database, regions, exact = exact,
boundary = boundary, interior = interior,
projection = projection, parameters = parameters,
orientation = orientation, plot = FALSE)
xyplot(y ~ x, theMap, type = type, aspect = aspect,
par.settings = par.settings, xlab = xlab, ylab = ylab,
default.scales = list(draw = FALSE), ...)
}
## Plot the sites on a map of Australia
if (require("maps")) {
lmap(regions = c("Australia", "Australia:Tasmania"),
exact = TRUE, projection = "rectangular",
parameters = 150, xlim = c(130, 170),
panel = function(...) {
panel.xyplot(...)
with(EastAuClimate, {
panel.points(Longitude, Latitude, pch = 16)
txt <- row.names(EastAuClimate)
i <- c(3, 4)
panel.text(Longitude[ i], Latitude[ i], txt[ i], pos = 2)
panel.text(Longitude[-i], Latitude[-i], txt[-i], pos = 4)
})
})
}
xyplot(WinterMaxTemp ~ Latitude, EastAuClimate, aspect = "xy",
type = c("p", "a"), ylab = "Temperature (degrees C)")
siteNames <- factor(row.names(EastAuClimate),
levels = row.names(EastAuClimate))
## Plot temperature ranges (as bars), color-coded by RainDays
segplot(siteNames ~ WinterMinTemp + SummerMaxTemp, EastAuClimate,
level = RainDays, sub = "Color scale: number of rainy days per year",
xlab = "Temperature (degrees C)",
main = paste("Typical temperature range and wetness",
"of coastal Australian cities", sep = "\n"))
xyplot(SummerRain + WinterRain ~ Latitude, EastAuClimate,
type = c("p", "a"), auto.key = list(lines = TRUE),
ylab = "Rainfall (mm / month)")
data(biocAccess)
xyplot(stl(ts(biocAccess$counts[1:(24 * 30)], frequency = 24), "periodic"))
xyplot(stl(log(co2), s.window=21),
main = "STL decomposition of CO2 data")
xyplot(stl(nottem, s.window = 4)) +
as.layer(xyplot(stl(nottem, s.window = "periodic")), style = 2)
xyplot(stl(nottem, s.window = 4), superpose=TRUE,
screens = list(data = "trend", trend = "trend", "residuals"),
strip.left = TRUE, layout = c(1,2))
ts.union(mdeaths, fdeaths)
data(mdeaths)
mdeaths
str(mdeaths)
fdeaths
plot(fdeaths)
plot(mdeaths)
ts.intersect(window(mdeaths, 1976), window(fdeaths, 1974, 1978))
dput(head(Dat, 10))
structure(list(open_date = structure(c(11742, 11966, 11987, 12001,
12015, 12029, 12043, 12064, 12085, 12099), class = "Date"), Dry_w = c(2.4,
14.05, 28.55, 20.76, 18.6, NA, 20.72, 18.47, 12.42, 25.57), PP_int = c(NA,
1281.52, 1352.15, 1333.05, 959.6, 738.24, 176.73, NA, 108.61,
518.42)), .Names = c("open_date", "Dry_w", "PP_int"), row.names = 166:175,
class = "data.frame")
clim.m <- aggregate(Dat, by=list(Month=format(Dat$open_date, "%m")),
> mean, na.rm=TRUE)
clim.m <- aggregate(Dat, by=list(Month=format(Dat$open_date, "%m")), mean, na.rm=TRUE)
Dat<-structure(list(open_date = structure(c(11742, 11966, 11987, 12001,
12015, 12029, 12043, 12064, 12085, 12099), class = "Date"), Dry_w = c(2.4,
14.05, 28.55, 20.76, 18.6, NA, 20.72, 18.47, 12.42, 25.57), PP_int = c(NA,
1281.52, 1352.15, 1333.05, 959.6, 738.24, 176.73, NA, 108.61,
518.42)), .Names = c("open_date", "Dry_w", "PP_int"), row.names = 166:175,
class = "data.frame")
clim.m <- aggregate(Dat, by=list(Month=format(Dat$open_date, "%m")), mean, na.rm=TRUE)
View(clim.m)
View(Dat)
View(clim.m)
clim.sd <- aggregate(Dat, by=list(Month=format(Dat$open_date, "%m")), sd,  na.rm=TRUE)
View(clim.sd)
Month <- format(Dat$open_date, "%m")
anom <- Dat$Dry_w - ave(Dat$Dry_w, Month, FUN = function(x) mean(x,
na.rm = TRUE))
st.anom <- Dat$PP_int - ave(Dat$PP_int, Month, FUN = function(x) mean(x,
na.rm = TRUE))
st.anom <- anom / ave(Dat$Dry_int, Dat$month, FUN = function(x) sd(x, na.rm = TRUE))
nom <- Dat$Dry_int - ave(Dat$Dry_int, Dat$month, FUN = function(x) mean(x, na.rm = TRUE))
st.anom <- anom / ave(Dat$Dry_int, Dat$month, FUN = function(x) sd(x, na.rm = TRUE))
View(Dat)
nom <- Dat$Dry_int - ave(Dat$Dry_int, Month, FUN = function(x) mean(x, na.rm = TRUE))
st.anom <- anom / ave(Dat$Dry_int, Month, FUN = function(x) sd(x, na.rm = TRUE))
install.packages("seas")
setwd("~/Research/Studio/proper")
props<-c(0.01,0.03,0.05,0.07,0.09,0.11,0.13,0.15,0.17,0.19)
sum(props)
props2<-c(22+24+26+28)
sum(props2)
counts<-c(100,200,300,400,500,1000,1500,2500,3000)
base.assemblage<-outer(props,counts)
base.assemblage
sum(base.assemblage[,9])
#' ### Computation
#' An empty matrix is created to hold the output of the loop output.
#' The confidence inteval is calcualted for each base assemblage (columns).
#' A print commmand aids diagnostics of the function.
#+ compute-bounds, include = TRUE
lower.intervals<-matrix(ncol=ncol(base.assemblage),nrow=nrow(base.assemblage))
lower.detection <-matrix(ncol=ncol(base.assemblage),nrow=nrow(base.assemblage))
upper.intervals<-matrix(ncol=ncol(base.assemblage),nrow=nrow(base.assemblage))
upper.detection <-matrix(ncol=ncol(base.assemblage),nrow=nrow(base.assemblage))
arr <- array(0,c(9,10,4))
i=1
for (i in i:9) {
bounds<- betLB(base.assemblage[,i],counts[i])
lower.intervals[,i]<-round(bounds,3)
bounds.up<- betUB(base.assemblage[,i],counts[i])
upper.intervals[,i]<-round(bounds.up,3)
prevalence <-round(bounds*counts[i]/100,0)
lower.detection[,i] <- prevalence
prevalence.up <-round(bounds.up*counts[i]/100,0)
upper.detection[,i] <- prevalence.up
results <-list(lower.intervals,lower.detection,upper.intervals,upper.detection)
arr <-as.array(results)
}
# naming
source("howarthCI.R")
s
s
s
s
s
s
s
s
s
s
props<-c(0.01,0.03,0.05,0.07,0.09,0.11,0.13,0.15,0.17,0.19)
sum(props)
props2<-c(22+24+26+28)
sum(props2)
counts<-c(100,200,300,400,500,1000,1500,2500,3000)
base.assemblage<-outer(props,counts)
base.assemblage
sum(base.assemblage[,9])
#' ### Computation
#' An empty matrix is created to hold the output of the loop output.
#' The confidence inteval is calcualted for each base assemblage (columns).
#' A print commmand aids diagnostics of the function.
#+ compute-bounds, include = TRUE
lower.intervals<-matrix(ncol=ncol(base.assemblage),nrow=nrow(base.assemblage))
lower.detection <-matrix(ncol=ncol(base.assemblage),nrow=nrow(base.assemblage))
upper.intervals<-matrix(ncol=ncol(base.assemblage),nrow=nrow(base.assemblage))
upper.detection <-matrix(ncol=ncol(base.assemblage),nrow=nrow(base.assemblage))
arr <- array(0,c(9,10,4))
i=1
for (i in i:9) {
bounds<- betLB(base.assemblage[,i],counts[i])
lower.intervals[,i]<-round(bounds,3)
bounds.up<- betUB(base.assemblage[,i],counts[i])
upper.intervals[,i]<-round(bounds.up,3)
prevalence <-round(bounds*counts[i]/100,0)
lower.detection[,i] <- prevalence
prevalence.up <-round(bounds.up*counts[i]/100,0)
upper.detection[,i] <- prevalence.up
results <-list(lower.intervals,lower.detection,upper.intervals,upper.detection)
arr <-as.array(results)
}
# naming
colnames(lower.intervals)<-as.character(counts); colnames(upper.intervals)<-as.character(counts)
rownames(lower.intervals)<-as.character(props); rownames(upper.intervals)<-as.character(props)
arr[[3]]-arr[[1]]
#' ### Plotting
#' An empty matrix is created to hold the output of the loop output.
#' The confidence inteval is calcualted for each base assemblage (columns).
#' A print commmand aids diagnostics of the function.
#+ plot, include = TRUE
par(mfrow=c(2,2))
persp(base.assemblage,main = "Assemblage matrix (n)")
persp(arr[[1]], main = "Assembalge Lower Bounds")
persp(arr[[2]], main = "Assemblage Lower Expected Counts")
par(mfrow=c(1,1))
# interpolate the surface
library(fields)
w2 <- arr[[3]]-arr[[1]]
widths <- upper.intervals-lower.intervals # the width of the CI
frac.widths <- widths/(props*100) # the width of the CI normlaized to the proportion counted
object.dir<-list(x=props,y=counts,z=widths)
object.norm <-list(x=props,y=counts,z=frac.widths)
temp2<- seq(00.01,0.19,,140)
temp3<- seq(100,3000,,200)
make.surface.grid(list(temp2,temp3))-> loc2
interp.surface( object.dir, loc2)-> look.dir
interp.surface( object.norm, loc2)-> look.normalized
image.plot(as.surface(loc2, look.dir))
outcome.dir <- as.surface(loc2, look.dir)
outcome.norm <- as.surface(loc2, look.normalized)
library(plot3D)
par(mfrow=c(1,3))
image2D(x=outcome.dir$x,y=outcome.dir$y,outcome.dir$z,resfac = 5,)
image2D(x=outcome.norm$x,y=outcome.norm$y,outcome.norm$z,resfac = 5)
persp3D(z=outcome.norm$z)
listCI <- list(norm=outcome.norm$z,lognorm<-log(outcome.norm$z))
image2D(listCI,x = outcome.norm$x, y = outcome.norm$y, contour = TRUE,
main = c("normailzed", "log(normalized)"),resfac=3)
View(frac.widths)
View(betLB)
library(dplyr)
library("nycflights13")
lights2 <- flights %>% select(year:day, hour, origin, dest, tailnum, carrier)
View(lights2)
lights2 %>%
left_join(airlines)
lights2 %>% left_join(weather)
lights2 %>% left_join(planes, by = "tailnum")
lights2 %>% left_join(airports, c("dest" = "faa"))
lights2 %>% left_join(airports, c("origin" = "faa"))
(df1 <- data_frame(x = c(1, 2), y = 2:1))
df2 <- data_frame(x = c(1, 3), a = 10, b = "a"))
df2 <- data_frame(x = c(1, 3), a = 10, b = "a")
df1 %>% inner_join(df2) %>% knitr::kable()
df1 %>% left_join(df2)
right_join(x, y)
df1 %>% right_join(df2)
df2 %>% left_join(df1)
df1 %>% full_join(df2)
df1 <- data_frame(x = c(1, 1, 2), y = 1:3)
df2 <- data_frame(x = c(1, 1, 2), z = c("a", "b", "a"))
View(df1)
View(df2)
View(df1)
View(df2)
df1 %>% left_join(df2)
df1 %>% left_join(df2)
library("nycflights13")
flights %>%
anti_join(planes, by = "tailnum") %>%
count(tailnum, sort = TRUE)
df1 <- data_frame(x = c(1, 1, 3, 4), y = 1:4)
df2 <- data_frame(x = c(1, 1, 2), z = c("a", "b", "a"))
df1 %>% nrow()
df1 %>% nrow()
df1 %>% inner_join(df2, by = "x") %>% nrow()
df1 %>% semi_join(df2, by = "x") %>% nrow()
df1 %>% inner_join(df2, by = "x")
df1 %>% semi_join(df2, by = "x")
(df1 <- data_frame(x = 1:2, y = c(1L, 1L)))
(df2 <- data_frame(x = 1:2, y = 1:2))
intersect(df1, df2)
union(df1, df2)
setdiff(df1, df2)
setdiff(df2, df1)
setwd("~/Research/klim.dat/Demonstration")
